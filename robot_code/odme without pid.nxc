// NXT Line Follower with Odometry - Based on Working Code

#define LEFT_MOTOR     OUT_B
#define RIGHT_MOTOR    OUT_C
#define BOTH_MOTORS    OUT_BC

#define LIGHT_PORT     S3
#define US_PORT        S4

// Light thresholds
int centerLow      = 44;
int centerHigh     = 50;
int veryDarkMax    = 38;
int veryBrightMin  = 56;

// Speed settings
#define BASE_SPEED     80
#define SMALL_TURN     12
#define BIG_TURN       25

// Robot dimensions
#define WHEEL_DIAMETER_MM 56
#define AXLE_LENGTH_MM    120

// Stop distance
#define STOP_DISTANCE_CM  8

// Odometry variables
float robotX = 0.0;
float robotY = 0.0;
float robotTheta = 0.0;
long lastLeftDeg = 0;
long lastRightDeg = 0;

// File variables
string dataFileName = "path.txt";
byte fileHandle;
unsigned int fileSize = 0;

string floatToStr(float value, int decimalPlaces)
{
    int intPart = value;
    float fracPart = abs(value - intPart);

    int multiplier = 1;
    for (int i = 0; i < decimalPlaces; i++) {
        multiplier *= 10;
    }
    int fracInt = fracPart * multiplier;

    string result = NumToStr(intPart);
    result = StrCat(result, ".");

    string fracStr = NumToStr(fracInt);
    int zerosNeeded = decimalPlaces - strlen(fracStr);
    for (int i = 0; i < zerosNeeded; i++) {
        fracStr = StrCat("0", fracStr);
    }
    result = StrCat(result, fracStr);

    return result;
}

float degreesToMm(long deg)
{
    float circumference = (3.14159 * WHEEL_DIAMETER_MM);
    return (deg * circumference) / 360.0;
}

void openDataFile()
{
    DeleteFile(dataFileName);
    unsigned int fileSize_temp = 10000;
    byte result = CreateFile(dataFileName, fileSize_temp, fileHandle);

    if (result == LDR_SUCCESS) {
        string header = "Time,X,Y,Theta,Light,Dist\n";
        WriteLnString(fileHandle, header, fileSize);
    }
}

void saveDataPoint(long timeMs, int light, int distance)
{
    string xStr = floatToStr(robotX / 10.0, 2);
    string yStr = floatToStr(robotY / 10.0, 2);
    float thetaDeg = (robotTheta * 180.0) / 3.14159;
    string thetaStr = floatToStr(thetaDeg, 2);

    string line = "";
    line = StrCat(line, NumToStr(timeMs));
    line = StrCat(line, ",");
    line = StrCat(line, xStr);
    line = StrCat(line, ",");
    line = StrCat(line, yStr);
    line = StrCat(line, ",");
    line = StrCat(line, thetaStr);
    line = StrCat(line, ",");
    line = StrCat(line, NumToStr(light));
    line = StrCat(line, ",");
    line = StrCat(line, NumToStr(distance));

    WriteLnString(fileHandle, line, fileSize);
}

void closeDataFile()
{
    CloseFile(fileHandle);
}

void updateOdometry()
{
    long currentLeftDeg  = MotorRotationCount(LEFT_MOTOR);
    long currentRightDeg = MotorRotationCount(RIGHT_MOTOR);

    long deltaLeftDeg  = currentLeftDeg - lastLeftDeg;
    long deltaRightDeg = currentRightDeg - lastRightDeg;

    float deltaLeftMm  = degreesToMm(deltaLeftDeg);
    float deltaRightMm = degreesToMm(deltaRightDeg);

    float deltaDist = (deltaLeftMm + deltaRightMm) / 2.0;
    float deltaTheta = (deltaRightMm - deltaLeftMm) / AXLE_LENGTH_MM;

    if (abs(deltaTheta) < 0.001)
    {
        robotX += deltaDist * cos(robotTheta);
        robotY += deltaDist * sin(robotTheta);
    }
    else
    {
        float radius = deltaDist / deltaTheta;
        robotX += radius * (sin(robotTheta + deltaTheta) - sin(robotTheta));
        robotY += radius * (-cos(robotTheta + deltaTheta) + cos(robotTheta));
    }

    robotTheta += deltaTheta;

    while (robotTheta > 3.14159)  robotTheta -= 6.28318;
    while (robotTheta < -3.14159) robotTheta += 6.28318;

    lastLeftDeg  = currentLeftDeg;
    lastRightDeg = currentRightDeg;
}

void setMotorPower(int L, int R)
{
    if (L > 100) L = 100;
    if (L < -100) L = -100;
    if (R > 100) R = 100;
    if (R < -100) R = -100;

    if (L >= 0)
        OnFwd(LEFT_MOTOR, L);
    else
        OnRev(LEFT_MOTOR, -L);

    if (R >= 0)
        OnFwd(RIGHT_MOTOR, R);
    else
        OnRev(RIGHT_MOTOR, -R);
}

void followLine(long gStartTime)
{
    ClearScreen();
    TextOut(0, LCD_LINE1, "Following...");

    int updateCounter = 0;
    int pointsSaved = 0;

    while (true)
    {
        int dist = SensorUS(US_PORT);
        int light = Sensor(LIGHT_PORT);

        updateOdometry();

        updateCounter++;
        if (updateCounter >= 10)
        {
            long elapsedMs = CurrentTick() - gStartTime;
            saveDataPoint(elapsedMs, light, dist);
            pointsSaved++;
            updateCounter = 0;
        }

        ClearLine(LCD_LINE3);
        TextOut(0, LCD_LINE3, "X:");
        NumOut(20, LCD_LINE3, robotX / 10);
        TextOut(50, LCD_LINE3, "Y:");
        NumOut(65, LCD_LINE3, robotY / 10);

        ClearLine(LCD_LINE4);
        TextOut(0, LCD_LINE4, "Pts:");
        NumOut(30, LCD_LINE4, pointsSaved);
        TextOut(50, LCD_LINE4, "L:");
        NumOut(65, LCD_LINE4, light);

        ClearLine(LCD_LINE5);
        TextOut(0, LCD_LINE5, "Dist:");
        NumOut(40, LCD_LINE5, dist);

        if (dist > 0 && dist <= STOP_DISTANCE_CM)
        {
            Off(BOTH_MOTORS);

            long elapsedMs = CurrentTick() - gStartTime;
            saveDataPoint(elapsedMs, light, dist);
            pointsSaved++;
            closeDataFile();

            ClearScreen();
            TextOut(0, LCD_LINE1, "FINISHED!");
            TextOut(0, LCD_LINE2, "Points:");
            NumOut(50, LCD_LINE2, pointsSaved);
            TextOut(0, LCD_LINE3, "File saved:");
            TextOut(0, LCD_LINE4, dataFileName);

            PlayTone(1000, 50);
            Wait(300);
            PlayTone(1500, 50);

            Wait(8000);
            StopAllTasks();
        }

        int leftP  = BASE_SPEED;
        int rightP = BASE_SPEED;

        // FIXED: Reversed all correction directions
        if (light <= veryDarkMax)
        {
            // Very dark -> turn right
            leftP  = BASE_SPEED - BIG_TURN;    // Changed from +
            rightP = BASE_SPEED + BIG_TURN;    // Changed from -
        }
        else if (light < centerLow)
        {
            // Dark -> small turn right
            leftP  = BASE_SPEED - SMALL_TURN;  // Changed from +
            rightP = BASE_SPEED + SMALL_TURN;  // Changed from -
        }
        else if (light > veryBrightMin)
        {
            // Very bright -> turn left
            leftP  = BASE_SPEED + BIG_TURN;    // Changed from -
            rightP = BASE_SPEED - BIG_TURN;    // Changed from +
        }
        else if (light > centerHigh)
        {
            // Bright -> small turn left
            leftP  = BASE_SPEED + SMALL_TURN;  // Changed from -
            rightP = BASE_SPEED - SMALL_TURN;  // Changed from +
        }

        setMotorPower(leftP, rightP);
        Wait(7);
    }
}

task main()
{
    SetSensorLight(LIGHT_PORT);
    SetSensorUltrasonic(US_PORT);

    ClearScreen();
    TextOut(0, LCD_LINE1, "Line Follower");
    TextOut(0, LCD_LINE2, "With Odometry");
    Wait(1000);

    ResetRotationCount(LEFT_MOTOR);
    ResetRotationCount(RIGHT_MOTOR);

    lastLeftDeg = 0;
    lastRightDeg = 0;
    robotX = 0.0;
    robotY = 0.0;
    robotTheta = 0.0;

    ClearScreen();
    TextOut(0, LCD_LINE1, "Creating file...");
    openDataFile();
    TextOut(0, LCD_LINE2, "Starting...");
    Wait(500);

    long gStartTime = CurrentTick();

    followLine(gStartTime);
}
